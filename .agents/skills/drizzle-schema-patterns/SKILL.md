---
name: drizzle-schema-patterns
description: Patterns for defining Drizzle ORM schemas and deriving Zod validation schemas in this codebase. Use when adding new tables, writing migrations, or creating oRPC procedure input/output types.
---

# Drizzle Schema Patterns

## Where schemas live

All Drizzle table definitions belong in `server/db/schema.ts`. Do not split tables across multiple files.

## Defining a new table

Follow the conventions already in the file:

```typescript
// server/db/schema.ts
import { pgTable, text, integer, timestamp } from "drizzle-orm/pg-core"
import { user } from "./schema" // reference existing tables for FK

export const widgets = pgTable("widgets", {
  id:          text("id").primaryKey(),
  userId:      text("user_id").notNull().references(() => user.id, { onDelete: "cascade" }),
  title:       text("title").notNull(),
  score:       integer("score").notNull().default(0),
  createdAt:   timestamp("created_at").notNull(),
  updatedAt:   timestamp("updated_at").notNull(),
})
```

Column naming conventions:
- Primary key: `id` — `text`, always `.primaryKey()`
- Timestamps: `createdAt` / `updatedAt` — always `timestamp`, always `.notNull()`
- Foreign keys: name as `<entity>Id`, always `.references(() => table.id, { onDelete: "cascade" })`
- Enums: define with `pgEnum` near the top of the file before the table that uses them

After adding a table, generate and run the migration:

```bash
bun run db:generate   # generates SQL in drizzle/
bun run db:migrate    # applies it to the database
```

---

## Deriving Zod schemas with `createTableSchemas`

**Never hand-write Zod schemas that duplicate Drizzle table shapes.**
Use `createTableSchemas` from `lib/utils/table-schemas.ts` instead. The Drizzle
schema is the single source of truth; Zod schemas and TypeScript types flow from it.

### Column categories

Every column on a table belongs to one of four categories:

| Category | What it means | Examples |
|---|---|---|
| `system` | Auto-generated by DB/infrastructure. Visible to clients in responses, but never written explicitly by anyone. | `id`, `createdAt`, `updatedAt` |
| `serverOnly` | Owned by server business logic. **Never** surfaced to clients — not in requests, not in responses. | `userId`, `srsLevel`, `nextScheduledAt`, `fraudScore` |
| `createOnly` | Immutable after creation for **both** server and client. Can be set on first insert; dropped from all update schemas. | `type`, `productId` |
| *(unclassified)* | Freely readable by clients and writable on both create and update. | `title`, `userContent`, `notes` |

### Generated schemas

```
createTableSchemas(table, config) →

  select        all columns                                        server reads DB
  clientSelect  minus serverOnly                                   API response bodies
  clientCreate  minus system + serverOnly                          client POST bodies
  clientUpdate  minus system + serverOnly + createOnly, partial    client PATCH bodies  (id required)
  serverCreate  minus system                                       server INSERT bodies
  serverUpdate  minus system + createOnly, partial                 server UPDATE bodies (id required)
```

### Example

```typescript
import { createTableSchemas } from "@/lib/utils/table-schemas"
import { widgets } from "@/server/db/schema"
import { z } from "zod"

const widgetSchemas = createTableSchemas(widgets, {
  system:     ["id", "createdAt", "updatedAt"],
  serverOnly: ["userId", "score"],   // server computes score; userId from session
  createOnly: [],                    // nothing locked after creation in this table
})

// Compose joined shapes by extending clientSelect
export const WidgetWithOwnerSchema = widgetSchemas.clientSelect.extend({
  owner: z.object({ name: z.string() }),
})

// Derive TypeScript types from the Zod schemas
export type Widget = z.infer<typeof widgetSchemas.clientSelect>
export type WidgetWithOwner = z.infer<typeof WidgetWithOwnerSchema>
```

### Wiring into an oRPC router

```typescript
import { protectedProcedure } from "../orpc"
import { widgetSchemas, WidgetWithOwnerSchema } from "./widgets"
import { z } from "zod"

export const widgetsRouter = {
  list: protectedProcedure
    .output(z.array(WidgetWithOwnerSchema))
    .handler(/* ... */),

  create: protectedProcedure
    .input(widgetSchemas.clientCreate)
    .output(WidgetWithOwnerSchema)
    .handler(/* ... */),

  update: protectedProcedure
    .input(widgetSchemas.clientUpdate)   // id is already required here
    .output(WidgetWithOwnerSchema)
    .handler(/* ... */),

  delete: protectedProcedure
    .input(z.object({ id: z.string() }))
    .output(z.object({ success: z.literal(true) }))
    .handler(/* ... */),
}
```

### Column name typos are compile errors

The column names you pass to `createTableSchemas` are validated at compile time.
Passing a name that doesn't exist on the table is a TypeScript error:

```typescript
createTableSchemas(widgets, {
  system: ["id", "createdAt", "updatedAt"],
  serverOnly: ["userId", "oops"],  // TS error: '"oops"' is not assignable to ...
})
```
