---
name: drizzle-schema-patterns
description: Patterns for defining Drizzle ORM schemas and deriving Zod validation schemas in this codebase. Use when adding new tables, writing migrations, or creating oRPC procedure input/output types.
---

# Drizzle Schema Patterns

## Where schemas live

All Drizzle table definitions belong in `server/db/schema.ts`. Do not split tables across multiple files.

## Defining a new table

Follow the conventions already in the file:

```typescript
// server/db/schema.ts
import { pgTable, text, integer, timestamp } from "drizzle-orm/pg-core"
import { user } from "./schema" // reference existing tables for FK

export const widgets = pgTable("widgets", {
  id:          text("id").primaryKey(),
  userId:      text("user_id").notNull().references(() => user.id, { onDelete: "cascade" }),
  title:       text("title").notNull(),
  score:       integer("score").notNull().default(0),
  createdAt:   timestamp("created_at").notNull(),
  updatedAt:   timestamp("updated_at").notNull(),
})
```

Column naming conventions:
- Primary key: `id` — `text`, always `.primaryKey()`
- Timestamps: `createdAt` / `updatedAt` — always `timestamp`, always `.notNull()`
- Foreign keys: name as `<entity>Id`, always `.references(() => table.id, { onDelete: "cascade" })`
- Enums: define with `pgEnum` near the top of the file before the table that uses them

After adding a table, generate and run the migration:

```bash
bun run db:generate   # generates SQL in drizzle/
bun run db:migrate    # applies it to the database
```

---

## Deriving Zod schemas with `createTableSchemas`

**Never hand-write Zod schemas that duplicate Drizzle table shapes.**
Use `createTableSchemas` from `lib/utils/table-schemas.ts` instead. The Drizzle
schema is the single source of truth; Zod schemas and TypeScript types flow from it.

### Column categories

Every column belongs to one of five categories:

| Category | What it means | Examples |
|---|---|---|
| `system` | Auto-generated by DB/infrastructure. Visible to clients in responses, never written explicitly by anyone. | `id`, `createdAt`, `updatedAt` |
| `clientHidden` | Owned by server business logic. Never surfaced to clients — not in requests, not in responses. Server can freely create and update. | `userId`, `srsLevel`, `nextScheduledAt`, `fraudScore` |
| `createOnly` | Immutable after creation for **both** server and client. Set on first insert; dropped from all update schemas. | `type` |
| `clientCreateOnly` | Client may set on creation but cannot update afterwards. Server retains full create + update access. | `status` (client seeds `"pending"`, server transitions to `"processing"` etc.) |
| *(mutable)* | Freely readable by clients and writable on both create and update by both parties. | `title`, `userContent`, `notes` |

### Write-access matrix

|                    | client create | client update | server create | server update |
|--------------------|:---:|:---:|:---:|:---:|
| `system`           | ✗ | ✗ | ✗ | ✗ |
| `clientHidden`     | ✗ | ✗ | ✓ | ✓ |
| `createOnly`       | ✓ | ✗ | ✓ | ✗ |
| `clientCreateOnly` | ✓ | ✗ | ✓ | ✓ |
| *(mutable)*        | ✓ | ✓ | ✓ | ✓ |

### Generated schemas

```
select        all columns                                                       server reads DB
clientSelect  minus clientHidden                                                API response bodies
clientCreate  minus system + clientHidden                                       client POST bodies
clientUpdate  minus system + clientHidden + createOnly + clientCreateOnly       client PATCH bodies (id required)
serverCreate  minus system                                                      server INSERT bodies
serverUpdate  minus system + createOnly                                         server UPDATE bodies (id required)
```

### Example

```typescript
import { createTableSchemas } from "@/lib/utils/table-schemas"
import { orders } from "@/server/db/schema"
import { z } from "zod"

const orderSchemas = createTableSchemas(orders, {
  system:           ["id", "createdAt", "updatedAt"],
  clientHidden:     ["customerId", "fraudScore"],  // server sets from session / algorithm
  createOnly:       ["productId"],                 // locked for everyone after creation
  clientCreateOnly: ["status"],                    // client seeds; server transitions later
})

// Compose joined shapes by extending clientSelect
export const OrderWithItemsSchema = orderSchemas.clientSelect.extend({
  items: z.array(orderItemSchemas.clientSelect),
})

// Derive TypeScript types from the Zod schemas
export type Order = z.infer<typeof orderSchemas.clientSelect>
export type OrderWithItems = z.infer<typeof OrderWithItemsSchema>
```

### Wiring into an oRPC router

```typescript
import { protectedProcedure } from "../orpc"
import { orderSchemas, OrderWithItemsSchema } from "./orders"
import { z } from "zod"

export const ordersRouter = {
  list: protectedProcedure
    .output(z.array(OrderWithItemsSchema))
    .handler(/* ... */),

  create: protectedProcedure
    .input(orderSchemas.clientCreate)
    .output(OrderWithItemsSchema)
    .handler(/* ... */),

  update: protectedProcedure
    .input(orderSchemas.clientUpdate)   // id is already required here
    .output(OrderWithItemsSchema)
    .handler(/* ... */),

  delete: protectedProcedure
    .input(z.object({ id: z.string() }))
    .output(z.object({ success: z.literal(true) }))
    .handler(/* ... */),
}
```

### Column name typos are compile errors

The column names you pass to `createTableSchemas` are validated at compile time.
Passing a name that doesn't exist on the table is a TypeScript error:

```typescript
createTableSchemas(orders, {
  system:       ["id", "createdAt", "updatedAt"],
  clientHidden: ["customerId", "oops"],  // TS error: '"oops"' is not assignable to ...
})
```
